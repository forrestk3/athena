//////////////////easy ssh connector/////////////////////
#!/bin/bash

if [ "$1" == "db" ]; then
    echo "connect to DB"
    sshpass -p 'rocks' ssh -X sdn@athena.shlab.kr -p 12001
elif [ "$1" == "s1" ]; then
    echo "connect to spark instance1"
    sshpass -p 'rocks' ssh -X sdn@athena.shlab.kr -p 12004
elif [ "$1" == "s2" ]; then
    echo "connect to spark instance1"
    sshpass -p 'rocks' ssh -X sdn@athena.shlab.kr -p 12005
elif [ "$1" == "s3" ]; then
    echo "connect to spark instance1"
    sshpass -p 'rocks' ssh -X sdn@athena.shlab.kr -p 12006
elif [ "$1" == "build" ]; then
    echo "connect to spark instance1"
    sshpass -p 'rocks' ssh -X sdn@athena.shlab.kr -p 11001
else
echo "
onos
build)ONOS-build-JW - 192.168.1.111 (11001 - ssh) / 00-0C-29-46-FB-F5
      -Build remote file sharing 19021 / 9021
Spark
s1) SPARK-S01-JW - 192.168.1.124(12004 -ssh) / 00-0C-29-32-DB-C3
s2) SPARK-S02-JW - 192.168.1.125(12005 -ssh) / 00-0C-29-8E-53-AA
s3) SPARK-S03-JW - 192.168.1.126(12006 -ssh) / 00-0C-29-BE-2B-E9

DB
db) MongoDB-MD01-JW - 192.168.1.121(12001 - ssh) / 00-0C-29-10-0C-9F"
fi
///////////////////easy ssh connector done!/////////////////









>>>>>>>>>How to debug instances on lxc-instances?
sudo service onos stop
./karaf debug //run onos with debug forcely

>>>>>>>>>>To lxc container!
sudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 5005 -j DNAT --to 10.0.3.37:5005

>>>>>>>>>Auto source script
. ~/onos/tools/dev/bash_profile
. ~/.profile

>>>>>>>>>mininet.sh for three instnaces
#!/usr/bin/python

"""
Create a network where different switches are connected to
different controllers, by creating a custom Switch() subclass.
"""

from mininet.net import Mininet
from mininet.node import OVSSwitch, Controller, RemoteController
from mininet.topolib import TreeTopo
from mininet.log import setLogLevel
from mininet.cli import CLI

setLogLevel( 'info' )

# Two local and one "external" controller (which is actually c0)
# Ignore the warning message that the remote isn't (yet) running
c0 = RemoteController( 'c0', ip='10.0.3.37')
c1 = RemoteController( 'c1', ip='10.0.3.90')
c2 = RemoteController( 'c2', ip='10.0.3.133' )

cmap = { 's1': c0, 's2': c1, 's3': c2 }

class MultiSwitch( OVSSwitch ):
    "Custom Switch() subclass that connects to different controllers"
    def start( self, controllers ):
        return OVSSwitch.start( self, [ cmap[ self.name ] ] )

topo = TreeTopo( depth=2, fanout=2 )
net = Mininet( topo=topo, switch=MultiSwitch, build=False )
for c in [ c0, c1, c2 ]:
    net.addController(c)
net.build()
net.start()
CLI( net )
net.stop()




>>>>>>>>>>lxc start
sudo lxc-ls --fancy
sudo lxc-start -n onos1 -d
sudo lxc-stop -n onos1 -d











data_gen.sh
#!/usr/bin/python
from subprocess import call

for num in range(1,200):  #to iterate between 10 to 20
        counter = str(num) + str('m')
        call(["fallocate",'-l' , counter, str(num)])








#udp 1000
hyenae -I 1 -a udp -p 1000 -A 4 -s 00:00:00:00:00:17-10.%%%.%%%.6@% -d 00:00:00:00:00:11-10.0.0.7@% -E 30








#TCP Syn floods
hyenae -I 1 -a tcp -f s -A 4 -s 00:00:00:00:00:17-10.%%%.%%%.6@% -d 00:00:00:00:00:11-10.0.0.7@% -E 50












usecase3.py
#!/usr/bin/python

"""
Custom topology for Mininet, generated by GraphML-Topo-to-Mininet-Network-Generator.
"""
from mininet.topo import Topo
from mininet.net import Mininet
from mininet.node import RemoteController
from mininet.node import Node
from mininet.node import CPULimitedHost
from mininet.node import OVSSwitch
from mininet.link import TCLink
from mininet.cli import CLI
from mininet.log import setLogLevel
from mininet.util import dumpNodeConnections
from functools import partial

class GeneratedTopo( Topo ):
    "Internet Topology Zoo Specimen."

    def __init__( self, **opts ):
        "Create a topology."

        # Initialize Topology
        Topo.__init__( self, **opts )
        s1 = self.addSwitch( 's1' )
        s2 = self.addSwitch( 's2' )
        s3 = self.addSwitch( 's3' )

        target = self.addHost( 'targetFTP' )
        benign1 = self.addHost( 'b1' )
        benign2 = self.addHost( 'b2' )
        benign3 = self.addHost( 'b3' )
        benign4 = self.addHost( 'b4' )
        benign5 = self.addHost( 'b5' )
        bot = self.addHost( 'bot' )

        #switches
        self.addLink( s1, s2 )
        self.addLink( s1, s3 )

        #target
        self.addLink( target, s1 )

        #benign
        self.addLink( benign1, s2 )
        self.addLink( benign2, s2 )
        self.addLink( benign3, s2 )
        self.addLink( benign4, s3 )
        self.addLink( benign5, s3 )

        #bot
        self.addLink( bot, s2 )

topos = { 'generated': ( lambda: GeneratedTopo() ) }

# HERE THE CODE DEFINITION OF THE TOPOLOGY ENDS

# the following code produces an executable script working with a remote controller
# and providing ssh access to the the mininet hosts from within the ubuntu vm
controller_ip = ''

def setupNetwork(controller_ip):
    "Create network and run simple performance test"
    # check if remote controller's ip was set
    # else set it to localhost
    topo = GeneratedTopo()
    if controller_ip == '':
        #controller_ip = '10.0.2.2';
        controller_ip = '127.0.0.1';
    OVSSwitch13 = partial( OVSSwitch, protocols='OpenFlow13')
    net = Mininet(topo=topo, controller=lambda a: RemoteController( a, ip=controller_ip, port=6633 ), host=CPULimitedHost, link=TCLink, switch=OVSSwitch13)
    return net

def connectToRootNS( network, switch, ip, prefixLen, routes ):
    "Connect hosts to root namespace via switch. Starts network."
    "network: Mininet() network object"
    "switch: switch to connect to root namespace"
    "ip: IP address for root namespace node"
    "prefixLen: IP address prefix length (e.g. 8, 16, 24)"
    "routes: host networks to route to"
    # Create a node in root namespace and link to switch 0
    root = Node( 'root', inNamespace=False )
    intf = TCLink( root, switch ).intf1
    root.setIP( ip, prefixLen, intf )
    # Start network that now includes link to root namespace
    network.start()
    # Add routes from root ns to hosts
    for route in routes:
        root.cmd( 'route add -net ' + route + ' dev ' + str( intf ) )

def sshd( network, cmd='/usr/sbin/sshd', opts='-D' ):
    "Start a network, connect it to root ns, and run sshd on all hosts."
    switch = network.switches[ 0 ]  # switch to use
    ip = '10.123.123.1'  # our IP address on host network
    routes = [ '10.0.0.0/8' ]  # host networks to route to
    connectToRootNS( network, switch, ip, 8, routes )
    for host in network.hosts:
        host.cmd( cmd + ' ' + opts + '&' )

    # DEBUGGING INFO
    print
    print "Dumping host connections"
    dumpNodeConnections(network.hosts)
    print
    print "*** Hosts are running sshd at the following addresses:"
    print
    for host in network.hosts:
        print host.name, host.IP()
    print
    print "*** Type 'exit' or control-D to shut down network"
    print
    print "*** For testing network connectivity among the hosts, wait a bit for the controller to create all the routes, then do 'pingall' on the mininet console."
    print

    CLI( network )
    for host in network.hosts:
        host.cmd( 'kill %' + cmd )
    network.stop()


if __name__ == '__main__':
    setLogLevel('info')
    #setLogLevel('debug')
    sshd( setupNetwork(controller_ip) )










server.sh
python -m pyftpdlib -p 21














client.sh
#sudo apt-get install python-pip -y && sudo pip install pyftpdlib
while (true); do
    wget --limit-rate 500M ftp://10.0.0.2/Interstellar.mkv
    sudo rm -rf ./Interstellar.mkv
    sleep 5;
done














